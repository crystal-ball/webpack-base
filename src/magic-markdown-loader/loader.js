/* eslint-env node */
// ‚ÑπÔ∏è CJS modules until webpack 4
const frontMatter = require('front-matter')
const { interpolateName } = require('loader-utils')

const parser = require('./parser')

/**
 * üîÆ The magic markdown loader is used for importing markdown files. The loader
 * parses the markdown body to html and wraps it in a React class component, this
 * effectively transforms the html markup to jsx. Passing this to the Babel loader
 * will transpile the JSX to executable JS in the bundle üéâ
 */
module.exports = function loader(source) {
  // For better identification, pull the file name out of the resource path and
  // transform it into a component name used in created component source
  const fileName = interpolateName({ resourcePath: this.resourcePath }, '[name]', {
    content: '',
  })

  // Pascal case the file name for component name
  let componentName = fileName
    .replace(/\s/g, '')
    .replace(/-([a-z])/g, (match, p1) => p1.toUpperCase())
  componentName = `${componentName.slice(0, 1).toUpperCase()}${componentName.slice(
    1
  )}`

  // Extract front matter data and parse source markdown body to HTML
  const { body = '', attributes = {} } = frontMatter(source)
  const html = parser(body)

  // create a unique set of component names used in the markdown that can be
  // destructured off of the REGISTRY in the created component source
  let componentNames = html.match(/<([A-Z][A-za-z]+)/g) || []
  componentNames = componentNames.map(component => component.slice(1))
  componentNames = [...new Set(componentNames)]

  /*
   * üéâ React component class defintion that wraps the parsed JSX.
   *
   * ‚ÑπÔ∏è Important Notes
   * * All of the components used in the source content are destructured off of the
   *   REGISTRY
   * * JSX is wrapped in a Fragment because it won't have a top level element.
   * * The front matter attributes are set as state on the component and
   *   destructured in the render method for ease of access
   * * Variable declarations for front matter and registry components use `let` so
   *   that they can be used in any way in the body, including reassignment
   *
   * ‚ö†Ô∏è Attention This component MUST be run through the Babel loader to transpile
   * the JSX into `createElement` calls.
   */
  return `import React, { Component, Fragment } from 'react'
import { object } from 'prop-types'

// üîÆ Magic Markdown Component
// This component is generated by the magic-markdown loader during the webpack
// build process.
class ${componentName} extends Component {

  constructor() {
    super()
    // Source front matter is set as state
    this.state = ${JSON.stringify(attributes)}
  }

  render() {
    let { props, context } = this
    let { REGISTRY = {} } = context

    // Destructure components used in body from REGISTRY
    let {${componentNames.toString()}} = REGISTRY
    // Destructure front matter to local variables
    let {${Object.keys(attributes).toString()}} = this.state

    return <Fragment>${html}</Fragment>
  }
}

${componentName}.contextTypes = {
  REGISTRY: object,
  THEME: object,
}

export default ${componentName}`
}
